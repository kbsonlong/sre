<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Grafana Mimir 和 VictoriaMetrics 之间的性能测试 - 蜷缩的蜗牛</title><meta name=author content="kbsonlong"><meta name=author-link content><meta name=description content="Grafana 实验室的 Mimir 是一个在 AGPLv3 许可下新的时间序列数据库，该工程团队从 Cortex TSDB 中汲取精华，同时降低了复杂性并提高了可扩展性。 根据 Grafana 实验室的测试，Mimir"><meta name=keywords content="grafana,monitor,转载"><meta itemprop=name content="Grafana Mimir 和 VictoriaMetrics 之间的性能测试"><meta itemprop=description content="Grafana 实验室的 Mimir 是一个在 AGPLv3 许可下新的时间序列数据库，该工程团队从 Cortex TSDB 中汲取精华，同时降低了复杂性并提高了可扩展性。 根据 Grafana 实验室的测试，Mimir"><meta itemprop=datePublished content="2022-09-14T12:20:51+08:00"><meta itemprop=dateModified content="2022-09-14T12:20:51+08:00"><meta itemprop=wordCount content="6709"><meta itemprop=image content="https://kbsonlong.github.io/logo_transparent.png"><meta itemprop=keywords content="grafana,monitor,转载,"><meta property="og:title" content="Grafana Mimir 和 VictoriaMetrics 之间的性能测试"><meta property="og:description" content="Grafana 实验室的 Mimir 是一个在 AGPLv3 许可下新的时间序列数据库，该工程团队从 Cortex TSDB 中汲取精华，同时降低了复杂性并提高了可扩展性。 根据 Grafana 实验室的测试，Mimir"><meta property="og:type" content="article"><meta property="og:url" content="https://kbsonlong.github.io/sre/posts/6650ff/"><meta property="og:image" content="https://kbsonlong.github.io/logo_transparent.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-14T12:20:51+08:00"><meta property="article:modified_time" content="2022-09-14T12:20:51+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kbsonlong.github.io/logo_transparent.png"><meta name=twitter:title content="Grafana Mimir 和 VictoriaMetrics 之间的性能测试"><meta name=twitter:description content="Grafana 实验室的 Mimir 是一个在 AGPLv3 许可下新的时间序列数据库，该工程团队从 Cortex TSDB 中汲取精华，同时降低了复杂性并提高了可扩展性。 根据 Grafana 实验室的测试，Mimir"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://kbsonlong.github.io/sre/posts/6650ff/><link rel=prev href=https://kbsonlong.github.io/sre/posts/d2d1d6/><link rel=next href=https://kbsonlong.github.io/sre/posts/2da521/><link rel=stylesheet href=/sre/lib/normalize/normalize.min.css><link rel=stylesheet href=/sre/css/style.min.css><link rel=stylesheet href=/sre/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/sre/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Grafana Mimir 和 VictoriaMetrics 之间的性能测试","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kbsonlong.github.io\/sre\/posts\/6650ff\/"},"genre":"posts","keywords":"grafana, monitor, 转载","wordcount":6709,"url":"https:\/\/kbsonlong.github.io\/sre\/posts\/6650ff\/","datePublished":"2022-09-14T12:20:51+08:00","dateModified":"2022-09-14T12:20:51+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"kbsonlong"},"description":""}</script></head><body header-desktop=sticky header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper github-corner=right><div class=header-title><a href=/sre/ title=蜷缩的蜗牛><img class="lazyload logo" src=/sre/svg/loading.min.svg data-src=/logo_transparent.png data-srcset="/logo_transparent.png, /logo_transparent.png 1.5x, /logo_transparent.png 2x" data-sizes=auto alt=蜷缩的蜗牛 title=蜷缩的蜗牛><span class=header-title-text>蜷缩的蜗牛</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/sre/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/sre/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/sre/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/sre/friends/ title=友情链接><i class='fa-solid fa-users fa-fw fa-sm'></i> 友链</a></li><li class=menu-item><a class=menu-link href=/sre/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=https://github.com/kbsonlong/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw'></i></a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=/sre/messages/><i class='fa-solid fa-messages'></i> 留言板</a></li><li class=menu-item><a class=menu-link href=/sre/messages/ title=留言板>留言板</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/sre/ title=蜷缩的蜗牛><img class="lazyload logo" src=/sre/svg/loading.min.svg data-src=/logo_transparent.png data-srcset="/logo_transparent.png, /logo_transparent.png 1.5x, /logo_transparent.png 2x" data-sizes=auto alt=/logo_transparent.png title=/logo_transparent.png><span class=header-title-text>蜷缩的蜗牛</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/sre/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/sre/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/sre/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/sre/friends/ title=友情链接><i class='fa-solid fa-users fa-fw fa-sm'></i> 友链</a></li><li class=menu-item><a class=menu-link href=/sre/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=https://github.com/kbsonlong/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw'></i></a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=/sre/messages/><i class='fa-solid fa-messages'></i> 留言板</a></li><li class=menu-item><a class=menu-link href=/sre/messages/ title=留言板>留言板</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Grafana Mimir 和 VictoriaMetrics 之间的性能测试</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img class="lazyload avatar" src=/sre/svg/loading.min.svg data-src="https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp" data-srcset="https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp, https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp 2x" data-sizes=auto alt=kbsonlong title=kbsonlong>&nbsp;kbsonlong</span></span>
<span class=post-category>收录于 <a href=/sre/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;云原生</a></span></div><div class=post-meta-line><span title="2022-09-14 12:20:51"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-09-14>2022-09-14</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 6709 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#方法>方法</a></li><li><a href=#prometheus-基准工具>Prometheus 基准工具</a></li><li><a href=#mimir-安装>Mimir 安装</a></li><li><a href=#victoriametrics-安装>VictoriaMetrics 安装</a></li><li><a href=#基准测试>基准测试</a><ul><li><a href=#快速统计>快速统计</a></li><li><a href=#结果>结果</a></li><li><a href=#副本>副本</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#探索极限>探索极限</a><ul><li><a href=#快速统计-1>快速统计</a></li><li><a href=#结果-1>结果</a></li></ul></li><li><a href=#总结-1>总结</a></li></ul></nav></div></div><div class=content id=content><p>Grafana 实验室的 <code>Mimir</code> 是一个在 AGPLv3 许可下新的时间序列数据库，该工程团队从 Cortex TSDB 中汲取精华，同时降低了复杂性并提高了可扩展性。</p><p>根据 Grafana 实验室的测试，Mimir 可以扩展到 10 亿个活跃时间序列和 5000 万个样本/秒的摄取率，该基准测试要求运行一个具有 7000 个 CPU 核心和 30TiB 内存的集群，这已经是我听说的最大、最昂贵的时间序列数据库的公共基准测试了。要重现这样规模的基准测试并不那么容易，幸运的是，在大多数情况下，用户的工作负荷要求要低得多，比较容易模拟。在本文我们将尝试比较 <code>VictoriaMetrics</code> 和 <code>Grafana Mimir</code> 集群在相同硬件上的中等工作负载下运行的性能和资源使用情况。</p><h2 id=方法>方法</h2><p>在比较两种不同产品的时候，最复杂的事情是保持透明和公正。尤其是当你对一种产品非常熟悉而对另一种产品完全陌生的时候。在这里我们要非常感谢 Mimir 的工程团队，我们在准备这个基准的过程中与他们进行了联系。我们非常感谢他们愿意开放地回答与产品有关的问题，并解释实的相关细节，这确实很有帮助。</p><p><code>VictoriaMetrics</code> 和 <code>Grafana Mimir</code> 都是时间序列数据库，支持大部分相同的协议和 API。但是，它们具有不同的架构和组件，这使得比较起来更加复杂。在基准测试中，我们将使用有限的资源，并根据我的理解将它们分配给两个集群。</p><p>然后，我将进行一轮基准测试，以了解两种解决方案如何处理相同的工作负载，以及它们在使用分配的资源方面的效率如何。</p><p>基准测试将在 <code>Google Kubernetes Engine</code> 中运行，该引擎由 <code>e2-standard-16</code> 节点（每个节点具有 16vCPU 和 64GiB 的 RAM）和基于 SSD 的标准持久卷组成。</p><h2 id=prometheus-基准工具>Prometheus 基准工具</h2><p>为了生成负载，我将使用 <code>Prometheus-benchmark</code>(<a href=https://github.com/VictoriaMetrics/prometheus-benchmark target=_blank rel="external nofollow noopener noreferrer">https://github.com/VictoriaMetrics/prometheus-benchmark</a>) 这个工具，它在 <code>VictoriaMetrics</code> 内部用于对新版本进行测试和基准测试。由于以下原因，该工具会产生类似生产的工作负载：</p><ul><li><p>作为摄取指标的来源，它使用真正的 <code>node_exporter</code> 目标，这通常是大多数生产环境的情况；</p></li><li><p>作为读取查询的来源，它使用 <code>node_exporter</code> 推荐的警报规则 列表；</p></li><li><p>非零指标流失率会产生额外的压力，模拟 Kubernetes 中周期性的 pods 重新部署的场景。</p></li></ul><p>Benchmark 运行两组相同的隔离服务，它们中的每一个都被配置为抓取指标，通过远程写入将它们转发到配置的存储，并定期执行警报规则。基准测试的配置如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># how frequently to scrape node_exporter targets
</span></span><span class=line><span class=cl>scrapeInterval: 15s
</span></span><span class=line><span class=cl># how often to execute configured rules
</span></span><span class=line><span class=cl>queryInterval: 15s
</span></span><span class=line><span class=cl># defines the number of node_exporter instances to scrape
</span></span><span class=line><span class=cl>targetsCount: 6000
</span></span><span class=line><span class=cl># percent of node_exporter targets to update
</span></span><span class=line><span class=cl>#  in order to generate series churn rate
</span></span><span class=line><span class=cl>scrapeConfigUpdatePercent: 1
</span></span><span class=line><span class=cl># specifies how frequently to update targets
</span></span><span class=line><span class=cl># for generating time series churn rate
</span></span><span class=line><span class=cl>scrapeConfigUpdateInterval: 10m
</span></span></code></pre></td></tr></table></div></div><blockquote><p>在 <a href=https://gist.github.com/hagen1778/a0824cde3903d6506e1b18eff7fd8b40 target=_blank rel="external nofollow noopener noreferrer">https://gist.github.com/hagen1778/a0824cde3903d6506e1b18eff7fd8b40</a> 此次可以查看使用的配置参数的完整列表。</p></blockquote><p>基准测试中的每个 node_exporter 目标产生大约 900 个（取决于 node_exporter 运行的硬件）时间序列，<code>targetCount=6000</code> 和 <code>scrapeInterval=15s</code> 以 360k 样本/秒 的摄取率产生大约 550 万个活跃时间序列到每个配置的远程存储。对于配置的警报列表，<code>queryInterval=15s</code> 通过即时查询生成大约 1.5 个查询/秒的读取负载。<code>scrapeConfigUpdatePercent=1</code> 和 <code>scrapeConfigUpdateInterval=10m</code> 产生每 10 分钟约 60k 新时间序列的 流失率 。</p><h2 id=mimir-安装>Mimir 安装</h2><p>我以前从未使用过 Cortex 或 Mimir，所以我从 官方文档 和一个分布式安装的 Helm Chart 开始探索这个项目。其架构如下图所示。</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124216.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124216.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124216.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124216.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124216.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124216.png></p><p>Mimir 分布式架构</p><p>从上图可以看出 Mimir 有 7 个不同的组件，给人的第一印象是一个复杂的系统。值得庆幸的是，helm chart 使事情变得更容易，而且还有根据有效负载提供了资源分配建议。大型工作负载的建议 要求大约 140 个 CPU 和 800GB 内存，用于 1000 万个活跃时间序列。对于一个简单的基准测试，显然这要求太高了，所以我从针对 100 万个活跃时间序列的小型工作负载的推荐配置开始，资源要求约为 30 个 CPU 和 200GB 内存。</p><p>通过几次测试运行，我发现推荐的容量规划是比较保守的。为 小型工作负载 所做的设置完全能够比这多出两倍，而且，通过对组件资源的一些手动调整，它还能够处理更多。</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124329.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124329.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124329.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124329.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124329.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124329.png></p><blockquote><p>helm chart 中有大约 7 个缓存副本和 <code>overrides_exporter</code>，没有设置明确的限制。我假设它们总共消耗约 1 个 CPU。</p></blockquote><p>可以在此处 <a href=https://gist.github.com/hagen1778/856fb6e99d7b1dfe284158ca8952a9fd target=_blank rel="external nofollow noopener noreferrer">https://gist.github.com/hagen1778/856fb6e99d7b1dfe284158ca8952a9fd</a> 找到 Helm Chart Values 值的完整覆盖列表。</p><p>在测试期间，我不得不突破以下限制：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>distributor:
</span></span><span class=line><span class=cl>  extraArgs:
</span></span><span class=line><span class=cl>    distributor.ingestion-rate-limit: &#34;10000000000000&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ingester:
</span></span><span class=line><span class=cl>  extraArgs:
</span></span><span class=line><span class=cl>    ingester.max-global-series-per-user: &#34;0&#34;
</span></span><span class=line><span class=cl>    ingester.max-global-series-per-metric: &#34;0&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>querier:
</span></span><span class=line><span class=cl>  extraArgs:
</span></span><span class=line><span class=cl>    querier.max-fetched-chunks-per-query: &#34;8000000&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mimir:
</span></span><span class=line><span class=cl>  structuredConfig:
</span></span><span class=line><span class=cl>    limits:
</span></span><span class=line><span class=cl>      out_of_order_time_window: 1h
</span></span></code></pre></td></tr></table></div></div><p>我在这个基准测试中使用了 <code>grafana/mimir:2.2.0</code> 这个发行版。</p><p>为了监控已部署的设置，我使用了 <a href=https://github.com/grafana/mimir/tree/main/operations/mimir-mixin-compiled target=_blank rel="external nofollow noopener noreferrer">https://github.com/grafana/mimir/tree/main/operations/mimir-mixin-compiled</a> 这里列出的仪表盘和记录规则。仪表盘的列表非常丰富和详细，但我发现由于以下原因，它不是很方便。</p><ul><li><p>我没有找到具有全局概览的仪表盘，只是为了显示集群是否一切正常；</p></li><li><p>仪表盘中的某些面板需要部署 记录规则 ，这是一个额外的步骤，有人可能会错过；</p></li><li><p>一些面板依赖于带有 <code>cortex_</code> 前缀和选择器的指标，例如 <code>job=~"(query-frontend.*|cortex|mimir)"</code>。Cortex 和 Mimir 前缀指标混合在一起，可能会让大家感到困惑。</p></li></ul><p>不过总的来说 Helm Chart 非常有用且易于理解，Mimir 的团队在这里做得很好，让新手更容易安装。</p><h2 id=victoriametrics-安装>VictoriaMetrics 安装</h2><p>VictoriaMetrics 集群架构如下所示：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124349.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124349.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124349.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124349.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124349.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124349.png></p><p>VictoriaMetrics 集群架构</p><p><code>VictoriaMetrics</code> 有 3 种不同类型的组件，也可以通过 helm chart 进行部署。<code>VictoriaMetrics</code> 集群的组件与 Mimir 的组件不同，其资源配置文件也不同。Mimir 的一些组件需要额外的内存，但 VictoriaMetrics 的组件需要额外的 CPU。因此，在资源分配方面，我将尽量在为 Mimir 分配的边界内。</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124410.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124410.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124410.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124410.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124410.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124410.png></p><blockquote><p>请注意，我们 建议 运行具有大量小型 <code>vmstorage</code> 节点的集群，而不是运行具有少量大型 <code>vmstorage</code> 节点的集群。</p></blockquote><p>VictoriaMetrics 的资源分配比 CPU 的限制多出约 1 个核心，但是内存少用了大约 80GiB，可以在 <a href=https://gist.github.com/hagen1778/bf143173b5512515950f41e3a9bd6005 target=_blank rel="external nofollow noopener noreferrer">https://gist.github.com/hagen1778/bf143173b5512515950f41e3a9bd6005</a> 这里找到完整的 helm chart values 值列表。</p><p>VictoriaMetrics 配置了 <code>-replicationFactor=2</code>，这与 Mimir 的默认复制因子 不同，这是 VictoriaMetrics 的推荐值，稍后会有更详细的介绍。</p><p>我在这个基准测试中使用的是 VictoriaMetrics/VictoriaMetrics:1.80.0-cluster 这个版本。</p><p>VictoriaMetrics 配备了 Grafana 仪表盘 和用于 自我监控的预定义警报规则 。</p><h2 id=基准测试>基准测试</h2><h3 id=快速统计>快速统计</h3><ul><li><p>该基准测试已运行 24 小时；</p></li><li><p>发送到 VictoriaMetrics 和 Mimir 的样本总数约为 310 亿：<code>360K 样本/秒 * 86400</code>；</p></li><li><p>基准测试期间生成的新时间序列总数约为 1360 万：<code>550 万初始序列 + 6K 系列/分钟 * 60 分钟 * 24</code>。</p></li></ul><p>在使用的 基准工具 中，摄取负载由 vmagent 生成。它暴露了许多有用的指标，好奇的读者可以在 Grafana 仪表板快照 上研究这些指标。根据这些指标，两个远程存储都可以很好地摄取，没有返回错误，没有丢失数据，每个指标都按预期交付。</p><p>如前所述，VictoriaMetrics 和 Mimir 都提供了用于监控的工具和仪表盘。为了客观地比较统计数据，我用 Mimir 的仪表盘所使用的磁盘、内存和 CPU 使用率的相同查询来制作了新的 Grafana 仪表盘。诸如<strong>摄取率</strong>、<strong>活跃时间序列</strong>或<strong>延迟</strong>等面板使用不同的指标，因为它们是由每个解决方案的内部组件导出的，该仪表盘的快照可在 <a href=https://snapshots.raintank.io/dashboard/snapshot/1lXGSoVm6xVDtKVZ8LFQvBCG1uDYKChJ target=_blank rel="external nofollow noopener noreferrer">https://snapshots.raintank.io/dashboard/snapshot/1lXGSoVm6xVDtKVZ8LFQvBCG1uDYKChJ</a> 获得。关于每个使用的查询的细节可以在面板的左上角找到。</p><h3 id=结果>结果</h3><p>Mimir 和 VictoriaMetrics 都完全能够处理 360k 样本/秒的摄取率：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124431.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124431.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124431.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124431.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124431.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124431.png></p><p>Mimir 和 VictoriaMetrics 的摄取率和活跃时间序列数</p><p>VictoriaMetrics 和 Mimir 之间的活跃时间序列数量略有不同，因为两种解决方案对它们的计算方式不同。由于非零流失率，Mimir 的活跃时间序列数量在不断增长，每 2 小时创建一个新的 TSDB 块时就会重置回来。</p><p>Ingester 是 Mimir 负责接收和处理写入的组件，将接收到的数据存储在内存中。这样的方法大大减少了写的放大作用，并有助于减少接触磁盘的频率。但是每 2 小时（可配置）Ingester 需要刷新磁盘上所有缓冲的数据，创建一个新的 TSDB 块并将其上传到对象存储。此操作对磁盘使用指标有影响：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124446.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124446.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124446.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124446.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124446.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124446.png></p><p>Mimir 和 VictoriaMetrics 的磁盘统计信息</p><p>虽然大多数时候 Mimir 的磁盘 IO 仍然很低，几乎比 VictoriaMetrics 低 2 倍，但每 2 小时 Mimir 就开始创建一个 TSDB 块，并消耗额外的磁盘资源。</p><p>解决方案之间的磁盘空间使用量情况为，VictoriaMetrics 的 49GiB 和 Mimir 的 369GiB。请注意，该面板仅考虑本地文件系统的大小。Mimir 还使用 Google Cloud Storage 进行长期存储，额外占用了 149GiB：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gsutil du -sh gs://mimir-bench-tsdb/
</span></span><span class=line><span class=cl>149.7 GiB    gs://mimir-bench-tsdb
</span></span></code></pre></td></tr></table></div></div><p>一个重要的注意事项是，Ingester 在本地文件系统上存储 TSDB 块，默认为 24 小时，可以查看 <code>-blocks-storage.tsdb.retention-period</code> 参数。因此本地文件系统上占用的磁盘大小可以大大减少。但是，在此测试中，仍然只有长期存储比 VictoriaMetrics 本地存储占用的空间多 3 倍。</p><p>在测试之后，还发现了其他细节。Compactor 在多个时间间隔内运行合并对象存储的数据块的压缩作业：默认为 2h、12h 和 24h。由于测试只运行了 24 小时，所以不可能发生所有的压缩作业。正确的压缩比较将需要运行多天的基准测试。</p><p>此外 VictoriaMetrics 的 CPU 使用率低于 Mimir 的：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124502.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124502.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124502.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124502.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124502.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124502.png></p><p>Mimir 和 VictoriaMetrics 的 CPU 使用率</p><p>对于好奇的读者，可以从仪表盘快照 <a href="https://snapshots.raintank.io/dashboard/snapshot/1lXGSoVm6xVDtKVZ8LFQvBCG1uDYKChJ?viewPanel=2" target=_blank rel="external nofollow noopener noreferrer">https://snapshots.raintank.io/dashboard/snapshot/1lXGSoVm6xVDtKVZ8LFQvBCG1uDYKChJ?viewPanel=2</a> 中查看有关每个 pod CPU 使用情况的详细信息。这些指标再次证明，这两个解决方案都具有非常不同的架构和组件设计。对于 Mimir 来说，最大的 CPU 用户是 Ingester —— 仅他们就平均消耗了 13 个 CPU 核，高峰时达到 18 个，利用率为其极限的 80%。对于 VictoriaMetrics 来说，vmselects 使用了大部分 CPU：平均 7 个 CPU，峰值高达 12 个 CPU 内核，利用率为其极限的 70%。在这个基准测试中，VictoriaMetrics 平均消耗的 CPU 比 Mimir 少 1.7 倍。</p><p>Mimir 和 VictoriaMetrics 的内存使用量也不同：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124517.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124517.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124517.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124517.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124517.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124517.png></p><p>Mimir 和 VictoriaMetrics 的内存使用</p><p>在此基准测试中，与 Mimir 相比，VictoriaMetrics 使用的内存少了大约 5 倍。可以在仪表盘快照 <a href=https://snapshots.raintank.io/dashboard/snapshot/1lXGSoVm6xVDtKVZ8LFQvBCG1uDYKChJ target=_blank rel="external nofollow noopener noreferrer">https://snapshots.raintank.io/dashboard/snapshot/1lXGSoVm6xVDtKVZ8LFQvBCG1uDYKChJ</a> 中找到组件之间的更详细比较。最有价值的收获是 Mimir 的 Ingester 运行非常接近极限，利用率为 80-90%，这意味着进一步增加负载可能会导致 OOM 异常。</p><p>读取查询的延迟具有以下统计信息：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124536.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124536.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124536.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124536.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124536.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124536.png></p><p>Mimir 和 VictoriaMetrics 的读取查询延迟</p><p>如前所述，读取负载只包括即时查询，并且由执行 node_exporter 指标的警报规则的外部 ruler 生成。规则列表包含轻量级查询和涉及数小时数据的重度查询。这会影响延迟，使得两个解决方案的第 50 百分位数在 100 到 500ms 之间，但是，<strong>Mimir 的第 99 百分位数最大为 47 秒</strong>，<strong>VictoriaMetrics 的最大为 20 秒</strong>。</p><blockquote><p>我没有在这个基准中测试范围查询，这将是未来运行的一个很好的测试场景。</p></blockquote><h3 id=副本>副本</h3><p>两种解决方案都有不同的复制方法。</p><p>在 Mimir，每个系列都由 distributors 复制给 ingesters，如果 Mimir 集群丢失了一个 ingester，则丢失的 ingester 持有的内存中的系列至少在另一个 ingester 中可用。因此，只要至少有一个副本还活着，读取查询就会成功。写入查询需要一定数量的副本才能成功，因此复制因子为 3 时，只有一个副本会丢失。</p><p>当 ingester 返回时，它会通过读取 WAL 来恢复其内存状态。恢复的 ingester 在离线时可能会丢失最近的数据，因此查询者需要查询所有 ingester 并合并数据以填补空白（如果有）。每隔 2 小时，每个 ingester 将 TSDB 数据块上传到对象存储，其中 compactor 合并数据块，如果有间隙，则对数据进行去重，所以只有一个样本被长期保存。</p><p>Mimir 的复制保护了在计划中的重启或由于硬件问题造成的意外 ingester 崩溃的情况下，不会丢失 ingester 内存中的最新数据。ingester 上的复制并不能保护无法到达的对象存储或对象存储上的数据损坏（由于人为错误或压缩错误）。对象存储的数据安全为存储提供商的责任。</p><p>在 VictoriaMetrics 中，每个系列都由 vminserts 复制到存储节点。这意味着，在任何时候，VictoriaMetrics 集群都会在存储节点上保存所有样本的 N 个副本。复制因子为 2 时，只有一个 vmstorage pod 可以丢失，以保持写入和读取成功。vmstorage 节点没有故意使用 WAL，因此它们可以非常快速地启动和运行。恢复的 vmstorage 在离线时可能会丢失最近的数据，因此 vmselects 需要查询所有 vmstorage 并合并数据以填补空白（如果有）。</p><p>VictoriaMetrics 的复制可防止丢失存储节点，这意味着，在整个时间范围内，一个或多个存储节点可以丢失、停用、更换或只是重新启动，而不会对整个时间范围内的读者产生影响。</p><p>虽然在这两种情况下，复制都是关于数据安全的，但它仍然不能保证数据安全。我们在 Google Cloud 中运行基准测试，使用 SSD 永久性磁盘 (SSD PD) 作为本地文件系统，并将 Cloud Storage 作为 Mimir 的对象存储。SSD PD 具有 5 个 9 的持久性，并在使用 x3 复制。如果我们假设 Cloud Storage 具有足够高的可用性而不进行复制，那么我们也可以对 SSD PD 进行相同的假设，并在数据可用性方面获得同等地位。即使 Cloud Storage 比 SSD PD 具有更高的可用性承诺 - Mimir 和 VictoriaMetrics 都会在 SSD PD 发生故障时面临写入和读取问题，尽管存在复制因素。</p><p>复制无法防止因资源不足或工作负载突然增加而导致的内存不足异常 (OOM)。在 VictoriaMetrics 和 Mimir 中，摄取的时间序列在各组件（分别为 vmstorage 和 ingester）之间均匀分片。因此，如果其中一个组件由于过载而开始出现 OOM，则很可能其他组件也会出现这种情况。这种情况可能会由于级联故障而导致数据丢失，组件开始一个接一个地崩溃。只有增加更多的资源或减少工作负荷，才能帮助摆脱这种情况。对于 VictoriaMetrics，我建议将复制因子设置为 2，以防止在维护或磁盘故障期间丢失一个 vmstorage 节点数据。如果需要更高的可用性，我们建议将复制下沉到 SSD PD 等持久存储或为集群分配额外资源。</p><p>Mimir 在复制后消除重复数据的能力非常酷。它不仅降低了存储成本，而且还应该提高了读取性能。VictoriaMetrics 从不删除复制数据的重复数据，以确保在某些 vmstorage 节点上的数据丢失时数据仍然可用于查询。</p><h3 id=总结>总结</h3><p>两种解决方案在处理负载方面都做得很好。没有发生故障或中断，系统在 24 小时的持续读写压力下保持稳定。但是，两种解决方案的不同架构都会产生影响。我可以肯定地说，Mimir 比 VictoriaMetrics 更<strong>耗费内存</strong>——对于相同的负载，它需要 5 倍以上的内存。在进一步扩展工作负载期间，内存是 Mimir 的瓶颈。即使我将 ingester 的复制因子从 3 降低到 2，它仍然需要比 VictoriaMetrics 更多的内存。</p><p>虽然没有一个集群达到它们的 CPU 限制，但 VictoriaMetrics 平均消耗的 CPU 比 Mimir 少了约 1.7 倍。</p><p>Mimir 的第 50 个百分点的延迟较好，但第 99 个百分点的延迟比 VictoriaMetrics 高一倍。目前尚不清楚是什么原因导致 Mimir 的延迟出现如此高的峰值。然而，阅读 Grafana Labs 团队进行其他测试文档，让我觉得 Mimir 在读取大时间范围内的指标时可以胜过 VictoriaMetrics，因为它需要扫描已经重复的数据。</p><p>VictoriaMetrics 的磁盘空间使用率较低。如果我们不考虑 ingesters 的本地文件系统，仅将 Mimir 的长期存储与 VictoriaMetrics 的磁盘使用情况进行比较——后者的磁盘空间使用量仍然是前者的 3 倍。虽然对象存储与 SSD PD 相比要便宜得多，但它也意味着数据访问的额外成本。阅读 Mimir 和 VictoriaMetrics 用户关于存储指标成本的评论会很有趣。</p><p>Mimir 有很大的规模潜力，每个组件都可以很容易地扩展。它还具有开箱即用的区域感知复制、对 ingester 和 querier 的可配置限制、高效的数据存储以及许多其他功能，例如查询分片。文档仍然需要一些优化，但总的来说我喜欢这个产品！</p><p>在此基准测试中，与 Mimir 在相同硬件上相比，VictoriaMetrics 表现出更高的资源效率和性能。从操作上讲，VictoriaMetrics 扩展有点复杂，因为数据存储在有状态的 vmstorage 节点上。这使得缩减 vmstorage 节点的数量变得非常重要。我建议在规划集群的架构时，一定要有相当数量的 vmstorage 节点。</p><p>在数据方面，基准测试结果如下：</p><ul><li><p>对于相同的工作负载，VictoriaMetrics 使用的 CPU 减少了 x1.7；</p></li><li><p>对于相同数量的活跃系列，VictoriaMetrics 使用的内存减少了 5 倍；</p></li><li><p>VictoriaMetrics 在基准测试期间收集的 24 小时数据使用的存储空间减少了 3 倍。</p></li></ul><h2 id=探索极限>探索极限</h2><p>在基准测试的极限探索回合中，我将只测试 VictoriaMetrics，因为 Mimir 负载的增加开始导致摄取器上的 OOM 异常。自上一个基准测试以来，仅更改了两个参数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=c1># defines the number of node_exporter instances to scrape
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>targetsCount</span><span class=p>:</span><span class=err> </span><span class=mi>8000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1># defines how many pods of writers to deploy.
</span></span></span><span class=line><span class=cl><span class=c1># each replica will scrape targetsCount targets and will have
</span></span></span><span class=line><span class=cl><span class=c1># its own extra label `replica` attached to written time series.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>writeReplicas</span><span class=p>:</span><span class=err> </span><span class=mi>4</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>该更改将唯一目标的数量从 6000 个增加到 8000 个，并启动了 4 个 vmagent 副本（每个副本都有唯一标签），这总共使负载增加了 <code>8000 * 4 / 6000 =~ 5 倍</code> 。</p><p>可以在此处 <a href=https://gist.github.com/hagen1778/dec1d6c73fb9cd1ae8f715ec5356a88e target=_blank rel="external nofollow noopener noreferrer">https://gist.github.com/hagen1778/dec1d6c73fb9cd1ae8f715ec5356a88e</a> 找到 helm chart values 的完整覆盖列表。</p><h3 id=快速统计-1>快速统计</h3><ul><li><p>基准测试已运行 3 小时；</p></li><li><p>发送到 VictoriaMetrics 的样本总数约为 195 亿：<code>180 万样本/秒 * 3 * 3600</code>；</p></li><li><p>基准测试期间生成的新时间序列总数约为 3180 万：<code>2750 万初始序列 + 24K 系列/分钟 * 60 分钟 * 3</code>。</p></li></ul><h3 id=结果-1>结果</h3><p>基准测试结果在上一轮基准中使用的仪表盘快照 <a href=https://snapshots.raintank.io/dashboard/snapshot/hoDTqThPYDoLQ6YfHeGsRVtTB80pMLG5 target=_blank rel="external nofollow noopener noreferrer">https://snapshots.raintank.io/dashboard/snapshot/hoDTqThPYDoLQ6YfHeGsRVtTB80pMLG5</a> 上获取。</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124553.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124553.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124553.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124553.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124553.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124553.png></p><p>VictoriaMetrics 的摄取率和活跃时间序列</p><p>我还抓取了 VictoriaMetrics 集群仪表板的快照 <a href=https://snapshots.raintank.io/dashboard/snapshot/J61xIFLm5oV2Q5MDaQ2kADq3JeG18RUQ target=_blank rel="external nofollow noopener noreferrer">https://snapshots.raintank.io/dashboard/snapshot/J61xIFLm5oV2Q5MDaQ2kADq3JeG18RUQ</a> ，其中包含每个组件的更详细指标。</p><p>VictoriaMetrics 在基准测试期间保持稳定，成功接收约 180 万个样本/秒和 2900 万个活跃时间序列（包括复制在内 5800 万个）。与之前的测试相比，CPU 利用率显着提高：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124607.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124607.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124607.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124607.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124607.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124607.png></p><p>VictoriaMetrics CPU 使用率</p><p>现在的平均使用率在 32 个可用核心中达到了约 26 个。如果检查每个 pod 的 CPU 利用率，我们会看到 vmstorage 平均以 80% 的速度运行，峰值高达 99%。这意味着进一步扩展需要更多的 CPU 用于 vmstorage 节点。</p><p>相反，VictoriaMetrics 只使用了允许内存的 1/4：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124621.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124621.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124621.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124621.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124621.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124621.png></p><p>VictoriaMetrics 内存使用</p><p>存储节点上内存的平均利用率约为 30%。这意味着，如果摄取率保持不变，则活跃时间序列的数量可以翻倍。</p><p>查询延迟随着负载的增加而显着降低：</p><p><img class=lazyload src=/sre/svg/loading.min.svg data-src=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124641.png data-srcset="https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124641.png, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124641.png 1.5x, https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124641.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124641.png title=https://raw.githubusercontent.com/kbsonlong/notes_statics/master/images/20220914124641.png></p><p>VictoriaMetrics 的读取查询延迟</p><p>仔细观察会发现 vmselects 之间的均衡性很差。VictoriaMetrics 集群 helm chart 使用标准 Kubernetes 服务进行负载均衡，但没有提供太大的灵活性。基于此基准测试的结果，我们计划 通过 nginx 使用更好的均衡策略 。类似于 Mimir 的 helm chart 中的操作方式。</p><h2 id=总结-1>总结</h2><p>基准测试文章总是很有趣的。写这些文章的目的是为了证明不同解决方案的优势和劣势，以展示令人印象深刻的数字和结论。但是，我必须警告，没有一个基准测试是客观的，通常与现实的关联性很弱。我鼓励读者针对他们的具体需求、硬件和数据运行自己的基准测试。只有这样，你才能确定经过测试的解决方案是否符合你的需求和期望。</p><p>特别感谢 Nikolay Khramchikhin 协助撰写这篇博文，并感谢 Mimir 的工程团队提供咨询！</p><blockquote><p>原文地址：https://victoriametrics.com/blog/mimir-benchmark/</p></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-09-14 12:20:51">更新于 2022-09-14</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/sre/posts/6650ff/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试" data-hashtags=grafana,monitor,转载><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-hashtag=grafana><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试" data-web><i class="fa-brands fa-whatsapp fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试"><i data-svg-src=/sre/lib/simple-icons/icons/line.min.svg></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试"><i class="fa-brands fa-weibo fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试" data-description><i data-svg-src=/sre/lib/simple-icons/icons/myspace.min.svg></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试" data-description><i class="fa-brands fa-blogger fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://kbsonlong.github.io/sre/posts/6650ff/ data-title="Grafana Mimir 和 VictoriaMetrics 之间的性能测试"><i class="fa-brands fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/sre/tags/grafana/>grafana</a>,&nbsp;<a href=/sre/tags/monitor/>monitor</a>,&nbsp;<a href=/sre/tags/%E8%BD%AC%E8%BD%BD/>转载</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/sre/>主页</a></span></section></div><div class=post-nav><a href=/sre/posts/d2d1d6/ class=prev rel=prev title=Iptable的概念><i class="fa-solid fa-angle-left fa-fw"></i>Iptable的概念</a>
<a href=/sre/posts/2da521/ class=next rel=next title="深入Ingress - Ingress Controller源码解析">深入Ingress - Ingress Controller源码解析<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kbsonlong/devops.alongparty.cn data-repo-id=R_kgDOHE7F-Q data-category=Announcements data-category-id=DIC_kwDOHE7F-c4CPP5J data-mapping=title data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/sre/>kbsonlong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw"></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span></div><div class="footer-line beian"><span class="icp footer-divider"><a target=_blank href=https://beian.miit.gov.cn/>粤ICP备18122209号</a></span></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><a href=https://github.com/kbsonlong title="在 GitHub 上查看源代码" target=_blank rel="external nofollow noopener noreferrer" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div></div><link rel=stylesheet href=/sre/lib/katex/katex.min.css><link rel=stylesheet href=/sre/lib/katex/copy-tex.min.css><link rel=stylesheet href=/sre/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/sre/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/sre/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script type=text/javascript src=/sre/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/sre/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/sre/lib/katex/katex.min.js defer></script><script type=text/javascript src=/sre/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/sre/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/sre/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/sre/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript src=/sre/lib/pangu/pangu.min.js defer></script><script type=text/javascript src=/sre/lib/cell-watermark/watermark.min.js defer></script><script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{giscus:{darkTheme:"dark",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,enablePangu:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"WFOR67TML1",algoliaIndex:"along",algoliaSearchKey:"ea1fe535f9a7ae353f3922489c829cc1",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},watermark:{appendto:".wrapper>main",colspacing:30,content:'<img class="fixit-icon" src="/favicon-16x16.png" alt="FixIt logo" /> FixIt 主题',enable:!0,fontfamily:"inherit",fontsize:.85,height:21,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script type=text/javascript src=/sre/js/theme.min.js defer></script><script type=text/javascript src=/sre/js/_custom.min.js defer></script></body></html>