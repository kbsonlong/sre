<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>如何选择最佳的Kubernetes集群自动伸缩策略 - 蜷缩的蜗牛</title><meta name=author content="kbsonlong"><meta name=author-link content><meta name=description content="前言 这篇内容篇幅比较长，如果不想深入探讨或时间有限，这是全文简述： 在默认设置下，扩展 Kubernetes 集群中的 pod 和节点可能需要几分钟时间。 了解如何调整集群节"><meta name=keywords content="自动伸缩"><meta itemprop=name content="如何选择最佳的Kubernetes集群自动伸缩策略"><meta itemprop=description content="前言 这篇内容篇幅比较长，如果不想深入探讨或时间有限，这是全文简述： 在默认设置下，扩展 Kubernetes 集群中的 pod 和节点可能需要几分钟时间。 了解如何调整集群节"><meta itemprop=datePublished content="2023-03-16T14:55:47+08:00"><meta itemprop=dateModified content="2023-03-16T14:55:47+08:00"><meta itemprop=wordCount content="6653"><meta itemprop=image content="https://www.alongparty.cn/logo_transparent.png"><meta itemprop=keywords content="自动伸缩,"><meta property="og:title" content="如何选择最佳的Kubernetes集群自动伸缩策略"><meta property="og:description" content="前言 这篇内容篇幅比较长，如果不想深入探讨或时间有限，这是全文简述： 在默认设置下，扩展 Kubernetes 集群中的 pod 和节点可能需要几分钟时间。 了解如何调整集群节"><meta property="og:type" content="article"><meta property="og:url" content="https://www.alongparty.cn/posts/a18401/"><meta property="og:image" content="https://www.alongparty.cn/logo_transparent.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T14:55:47+08:00"><meta property="article:modified_time" content="2023-03-16T14:55:47+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.alongparty.cn/logo_transparent.png"><meta name=twitter:title content="如何选择最佳的Kubernetes集群自动伸缩策略"><meta name=twitter:description content="前言 这篇内容篇幅比较长，如果不想深入探讨或时间有限，这是全文简述： 在默认设置下，扩展 Kubernetes 集群中的 pod 和节点可能需要几分钟时间。 了解如何调整集群节"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://www.alongparty.cn/posts/a18401/><link rel=prev href=https://www.alongparty.cn/posts/3e3c43/><link rel=next href=https://www.alongparty.cn/posts/5a662f/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"如何选择最佳的Kubernetes集群自动伸缩策略","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.alongparty.cn\/posts\/a18401\/"},"genre":"posts","keywords":"自动伸缩","wordcount":6653,"url":"https:\/\/www.alongparty.cn\/posts\/a18401\/","datePublished":"2023-03-16T14:55:47+08:00","dateModified":"2023-03-16T14:55:47+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"kbsonlong"},"description":""}</script></head><body header-desktop=sticky header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper github-corner=right><div class=header-title><a href=/ title=蜷缩的蜗牛><img class="lazyload logo" src=/svg/loading.min.svg data-src=/logo_transparent.png data-srcset="/logo_transparent.png, /logo_transparent.png 1.5x, /logo_transparent.png 2x" data-sizes=auto alt=蜷缩的蜗牛 title=蜷缩的蜗牛><span class=header-title-text>蜷缩的蜗牛</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class='fa-solid fa-users fa-fw fa-sm'></i> 友链</a></li><li class=menu-item><a class=menu-link href=/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=https://github.com/kbsonlong/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw'></i></a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=/messages/><i class='fa-solid fa-messages'></i> 留言板</a></li><li class=menu-item><a class=menu-link href=/messages/ title=留言板>留言板</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=蜷缩的蜗牛><img class="lazyload logo" src=/svg/loading.min.svg data-src=/logo_transparent.png data-srcset="/logo_transparent.png, /logo_transparent.png 1.5x, /logo_transparent.png 2x" data-sizes=auto alt=/logo_transparent.png title=/logo_transparent.png><span class=header-title-text>蜷缩的蜗牛</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class='fa-solid fa-users fa-fw fa-sm'></i> 友链</a></li><li class=menu-item><a class=menu-link href=/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=https://github.com/kbsonlong/ title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw'></i></a></li><li class="menu-item d-none-desktop text-center"><a class=menu-link href=/messages/><i class='fa-solid fa-messages'></i> 留言板</a></li><li class=menu-item><a class=menu-link href=/messages/ title=留言板>留言板</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>如何选择最佳的Kubernetes集群自动伸缩策略</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img class="lazyload avatar" src=/svg/loading.min.svg data-src="https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp" data-srcset="https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp, https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp 1.5x, https://gravatar.loli.net/avatar/598872715ec08296cf1e1806135cd518?s=32&amp;d=mp 2x" data-sizes=auto alt=kbsonlong title=kbsonlong>&nbsp;kbsonlong</span></span>
<span class=post-category>收录于 <a href=/categories/kubernetes/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Kubernetes</a></span></div><div class=post-meta-line><span title="2023-03-16 14:55:47"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-03-16>2023-03-16</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 6653 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#目录>目录</a><ul><li><a href=#当自动伸缩的-pod-报错>当自动伸缩的 Pod 报错</a></li><li><a href=#kubernetes-的-cluster-autoscaler-是如何工作的>Kubernetes 的 Cluster Autoscaler 是如何工作的</a></li><li><a href=#探索-pod-自动伸缩前置期>探索 Pod 自动伸缩前置期</a></li><li><a href=#为-kubernetes-节点选择最佳实例大小>为 Kubernetes 节点选择最佳实例大小</a></li><li><a href=#在-kubernetes-集群中过度配置节点>在 Kubernetes 集群中过度配置节点</a></li><li><a href=#为-pod-选择正确的内存和cpu资源>为 Pod 选择正确的内存和CPU资源</a></li><li><a href=#关于集群的缩容>关于集群的缩容</a></li><li><a href=#为什么不基于内存或cpu进行自动伸缩>为什么不基于内存或CPU进行自动伸缩</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=content id=content><h2 id=前言>前言</h2><p>这篇内容篇幅比较长，如果不想深入探讨或时间有限，这是全文简述：
在默认设置下，扩展 Kubernetes 集群中的 pod 和节点可能需要几分钟时间。
了解如何调整集群节点的大小、配置水平和集群自动缩放器以及过度配置集群以加快扩展速度。</p><h2 id=目录>目录</h2><ul><li>当自动伸缩的 Pod 报错</li><li>Kubernetes 的 Cluster Autoscaler 是如何工作的</li><li>探索 Pod 自动伸缩提前期</li><li>为 Kubernetes 节点选择最佳实例大小</li><li>在 Kubernetes 集群中过度配置节点</li><li>为 Pod 选择正确的内存和CPU资源</li><li>关于集群的缩容</li><li>为什么不基于内存或CPU进行自动伸缩</li></ul><p>在 Kubernetes 中, 自动伸缩功能包括:</p><ul><li><a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/ target=_blank rel="external nofollow noopener noreferrer">Pod水平自动伸缩（Horizontal Pod Autoscaler，HPA）</a></li><li><a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler target=_blank rel="external nofollow noopener noreferrer">Pod垂直自动伸缩（Vertical Pod Autoscaler，VPA）</a></li><li><a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler target=_blank rel="external nofollow noopener noreferrer">集群自动伸缩（Cluster Autoscaler，CA）</a></li></ul><p>这些自动伸缩组件属于不同的类别，关注点也不同。</p><p>Horizontal Pod Autoscaler 负责增加 Pod 的副本数量。随着你的应用接收到的流量越来越多，你可以让自动伸缩组件调整副本数量来处理更多的请求。</p><p>Vertical Pod Autoscaler 的使用场景是，当资源不足无法创建更多的 Pod 副本时，而又仍然需要处理更多的流量。
一个简单的例子，你无法通过简单地添加更多的 Pod 副本来扩容数据库。数据库可能需要进行数据分片或者配置只读节点。
但你可以通过增加内存和CPU资源来让数据库能够处理更多的连接数。
这正是 VPA 的目的，增加 Pod 的资源大小。</p><p>最后，我们要说说集群自动伸缩组件了。
当你的集群资源不足时，Cluster Autoscaler 会配置一个新的计算单元并将其添加到集群中。如果空节点过多，会移除它们以降低成本。</p><p>虽然这三个组件都 “自动伸缩” 了一些东西，但它们并不造成相互之间的干扰。它们各自都有自己使用场景，定义和工作机制。并且它们是在独立的项目中开发的，独立的使用。
然而，更重要的是，为了最好的 scaling 你的集群，你必须花些心思去设置好这些 Autoscaler，让我们看个例子。</p><h3 id=当自动伸缩的-pod-报错>当自动伸缩的 Pod 报错</h3><p>想象一下，有一个应用程序始终需要并使用 1.5GB 内存和 0.25 个 vCPU。
你配置了一个具有 8GB 和 2 个 vCPU 的单个节点的集群 —— 它应该能够完美地容纳四个 pod（并且还有一点额外的空间）。</p><p><figure><a class=lightgallery href=single-node.png title=single-node.png data-thumbnail=single-node.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=single-node.png data-srcset="single-node.png, single-node.png 1.5x, single-node.png 2x" data-sizes=auto alt=single-node.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>现在，你部署了一个 Pod 并且配置如下：</p><ol><li>HPA 配置每 10 个请求进来就添加一个 Pod 副本（例如：如果有 40 个并发请求涌入，会扩容到 4 个 Pod 副本）。</li><li>CA 配置在资源不足时，创建更多的 Node 节点。</li></ol><blockquote><p>HPA 可以通过在 deployment 文件中使用 Custom Metrics（例如在 Ingress Controller 中的 queries per second（QPS）） 来扩容 Pod 副本数量。</p></blockquote><p>现在，你开始为集群增加 30 个并发请求，并观察一下情况：</p><ol><li>HPA 开始扩容 Pod。</li><li>创建了两个 Pod 副本。</li><li>CA 没有触发 - 没有新增集群 Node 节点。</li></ol><p>这很好理解，因为现在有足够的内存和 CPU 资源来支持更多的 Pod。</p><p><figure><a class=lightgallery href=node-enogh.png title=node-enogh.png data-thumbnail=node-enogh.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=node-enogh.png data-srcset="node-enogh.png, node-enogh.png 1.5x, node-enogh.png 2x" data-sizes=auto alt=node-enogh.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>你进一步将流量增加到 40 个并发请求，并再次观察：</p><ol><li>HPA 又创建了一个 Pod。</li><li>这个 Pod 是 pending 状态并且无法被部署。</li><li>CA 触发创建了一个新的 Node 节点。</li><li>新 Node 节点启动 4 分钟后开始工作。之后，pending Pod 也成功被部署了。</li></ol><p><figure><a class=lightgallery href=pending-pod.png title=pending-pod.png data-thumbnail=pending-pod.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=pending-pod.png data-srcset="pending-pod.png, pending-pod.png 1.5x, pending-pod.png 2x" data-sizes=auto alt=pending-pod.png></a><figcaption class=image-caption>:size=700</figcaption></figure><figure><a class=lightgallery href=pending-pod-2.png title=pending-pod-2.png data-thumbnail=pending-pod-2.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=pending-pod-2.png data-srcset="pending-pod-2.png, pending-pod-2.png 1.5x, pending-pod-2.png 2x" data-sizes=auto alt=pending-pod-2.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>为什么第四个 Pod 没有部署在第一个 Node 节点上呢？</p><p>Pod 部署在集群上需要消耗内存，CPU，硬盘空间等资源，在同一个 Node 上，操作系统和 kubelet 组件也需要消耗内存和 CPU 资源。</p><p>Kubernetes 中一个 Worker Node 节点的内存和 CPU 等资源使用分布如下：</p><ol><li>需要运行操作系统和一些系统级的守护进程，例如 SSH，Systemd 等。</li><li>需要运行 Kubernetes Agent 组件，例如 Kubelet，Container Runtime，<a href=https://github.com/kubernetes/node-problem-detector target=_blank rel="external nofollow noopener noreferrer">Node Problem Detector</a> 等。</li><li>需要运行 Pod。</li><li>需要保留一些资源用来<a href=https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#eviction-thresholds target=_blank rel="external nofollow noopener noreferrer">驱逐阀值</a> 之用。</li></ol><p><figure><a class=lightgallery href=eviction-threshold.svg title=eviction-threshold.svg data-thumbnail=eviction-threshold.svg data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=eviction-threshold.svg data-srcset="eviction-threshold.svg, eviction-threshold.svg 1.5x, eviction-threshold.svg 2x" data-sizes=auto alt=eviction-threshold.svg></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>你猜的没错，所有这些配额都是可定制的，但你需要好好计算一下。</p><p>在一个 8GB 内存和 2vCPU 的单个节点的，可以按如下估算：</p><ul><li>操作系统运行大概需要 100MB 内存和 0.1vCPU。</li><li>kubelet 运行大概需要 1.8GB 内存和 0.07vCPU。</li><li>驱逐阀值大概需要 100MB 内存。</li></ul><p>剩余的大约 6GB 内存空间和 1.83vCPU 是提供给 Pod 使用的。</p><p>如果你的集群需要运行 DaemonSet 资源，像 kube-proxy，那么你应该进一步减少提供给 Pod 的资源。考虑到 kube-proxy 大概需要 128MB 内存和 0.1vCPU，那么剩余大约 5.9GB 内存空间和 1.73vCPU 是提供给 Pod 使用的。</p><p>另外，如果还需要运行 CNI 组件（例如：Flannel）和日志收集组件（Flentd），又会进一步减少提供给 Pod 的资源。</p><p>在统计完所有其他的资源占用情况后，集群的剩余空间就只够运行三个 Pod 了。</p><p><figure><a class=lightgallery href=left-space-pod.png title=left-space-pod.png data-thumbnail=left-space-pod.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=left-space-pod.png data-srcset="left-space-pod.png, left-space-pod.png 1.5x, left-space-pod.png 2x" data-sizes=auto alt=left-space-pod.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>所以第四个会一直保持 “pending” 状态，直到它被调度到其他的 Node 节点上。</p><p>既然 Cluster Autoscaler 知道没有空间容纳第四个 Pod，为什么不提前配置一个新节点？
为什么它要在 Pod 处于 “pending” 状态之后再触发创建新 Node 节点的操作？</p><h3 id=kubernetes-的-cluster-autoscaler-是如何工作的>Kubernetes 的 Cluster Autoscaler 是如何工作的</h3><p>Cluster Autoscaler 不是通过观察内存或 CPU 的使用情况来触发自动伸缩的。相反地，是通过对事件的响应和每 10s 对不可调度的 Pod 进行检查。</p><p>当 Scheduler 无法找到可以容纳它的 Node 节点时，Pod 就会变成不可调度状态。例如，当一个 Pod 需要 1vCPU 资源而集群只有 0.5vCPU 资源可用，Scheduler 就会把该 Pod 标记为不可调度状态。</p><p>这时，Cluster Autoscaler 会开始创建新 Node 节点。创建完成后，它会扫描集群中的不可调度状态的 Pod，<a href=https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders target=_blank rel="external nofollow noopener noreferrer">检查是否可以将这些 Pod 调度到新节点上</a>。</p><p>如果你的集群具有多种节点类型（通常也称为节点组或节点池），则 Cluster Autoscaler 将使用以下策略选择其中一种：</p><ul><li>Random - 随机选择一种节点类型（默认策略）。</li><li>Most Pods - 选择将调度最多 Pod 的节点组。</li><li>Least waste - 选择扩容后空闲 CPU 最少的节点组。</li><li>Price - 选择成本最低的节点组（目前仅适用于 GCP）。</li><li>Priority - 选择优先级最高的节点组（优先级可以手动设置）。</li></ul><p>一旦确定了节点类型，Cluster Autoscaler 将调用相关 API 来提供新的计算资源。</p><p>如果你使用的是 AWS，Cluster Autoscaler 将预置一个新的 EC2 实例。在 Azure 上，它将创建一个新的虚拟机，并在 GCP 上创建一个新的计算引擎。</p><p>创建的节点可能需要一些时间才能出现在 Kubernetes 中。计算资源准备就绪后，节点将被初始化并添加到可以部署未被调度 Pod 的集群中。</p><p>不幸的是，配置一个新节点通常会很慢。它可能会花费好几分钟来做这件事。</p><p>让我们来看看这几分钟到底干了什么。</p><h3 id=探索-pod-自动伸缩前置期>探索 Pod 自动伸缩前置期</h3><p>在新节点上创建新 Pod 所需的时间由四个主要因素决定：</p><ol><li>HPA 的反应时间。</li><li>CA 的反应时间。</li><li>Node 节点的反应时间。</li><li>Pod 创建的时间。</li></ol><p>默认地，<a href=https://github.com/kubernetes/kubernetes/blob/2da8d1c18fb9406bd8bb9a51da58d5f8108cb8f7/pkg/kubelet/kubelet.go#L1855 target=_blank rel="external nofollow noopener noreferrer">kubelet 每 10 秒抓取一次 Pod 的 CPU 和内存使用情况</a>。每分钟，<a href=https://github.com/kubernetes-sigs/metrics-server/blob/master/FAQ.md#how-often-metrics-are-scraped target=_blank rel="external nofollow noopener noreferrer">Metrics Server 都会聚合这些指标</a>并将它们发送给 Kubernetes API 的其他组件。</p><p>Horizontal Pod Autoscaler 控制器负责检查指标并决定扩大或缩小副本数量。</p><p>默认地，<a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#how-does-the-horizontal-pod-autoscaler-work target=_blank rel="external nofollow noopener noreferrer">Horizontal Pod Autoscaler 每 15 秒检查一次 Pod 指标</a>。</p><p><a href=https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-up-work target=_blank rel="external nofollow noopener noreferrer">Cluster Autoscaler 每 10 秒检查一次集群中不可调度的 Pod</a>。</p><p>一旦 CA 检测到不可调度的 Pod，它就会运行一个算法来做决策：</p><ol><li>需要多少个节点来将所有的不可调度 Pod 部署完成。</li><li>需要创建那种类型的节点组。</li></ol><p>整个过程的时间花费应该是：</p><ul><li>在少于 100 个节点且每个节点最多 30 个 Pod 的集群上不超过 30 秒。 平均延迟应该是大约 5 秒。</li><li>在具有 100 到 1000 个节点的集群上不超过 60 秒。 平均延迟应约为 15 秒。</li></ul><p><figure><a class=lightgallery href=hpa-ca-time.png title=hpa-ca-time.png data-thumbnail=hpa-ca-time.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=hpa-ca-time.png data-srcset="hpa-ca-time.png, hpa-ca-time.png 1.5x, hpa-ca-time.png 2x" data-sizes=auto alt=hpa-ca-time.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>然后是节点配置时间，这主要取决于云提供商。在 3-5 分钟内供应新的计算资源是非常标准的。</p><p><figure><a class=lightgallery href=hpa-ca-time-2.png title=hpa-ca-time-2.png data-thumbnail=hpa-ca-time-2.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=hpa-ca-time-2.png data-srcset="hpa-ca-time-2.png, hpa-ca-time-2.png 1.5x, hpa-ca-time-2.png 2x" data-sizes=auto alt=hpa-ca-time-2.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>最后，Pod 必须由容器运行时创建。启动一个容器应该不会超过几毫秒，但下载容器镜像可能需要几秒钟。
如果没有缓存容器映像，则从容器注册表下载映像可能需要几秒钟到一分钟的时间，具体取决于层的大小和数量。</p><p><figure><a class=lightgallery href=hpa-ca-time-3.png title=hpa-ca-time-3.png data-thumbnail=hpa-ca-time-3.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=hpa-ca-time-3.png data-srcset="hpa-ca-time-3.png, hpa-ca-time-3.png 1.5x, hpa-ca-time-3.png 2x" data-sizes=auto alt=hpa-ca-time-3.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>因此，当集群中没有空间而触发自动伸缩的时间消耗如下：</p><ol><li>Horizontal Pod Autoscaler 可能需要长达 1min30s 来增加副本数量。</li><li>对于少于 100 个节点的集群，Cluster Autoscaler 应该花费不到 30s 的时间，对于超过 100 个节点的集群，应该不到 1min。</li><li>云提供商可能需要 3-5min 来创建计算机资源。</li><li>容器运行时可能需要长达 30s 才能下载容器映像。</li></ol><p>如果你的集群规模不是很大，在最坏的情况下，时间消耗：</p><p><figure><a class=lightgallery href=hpa-ca-time-4.png title=hpa-ca-time-4.png data-thumbnail=hpa-ca-time-4.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=hpa-ca-time-4.png data-srcset="hpa-ca-time-4.png, hpa-ca-time-4.png 1.5x, hpa-ca-time-4.png 2x" data-sizes=auto alt=hpa-ca-time-4.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>对于超过 100 个节点的集群，总延迟可能高达 7 分钟。在有更多 Pod 来处理突然激增的流量之前，您是否愿意等待这 7 分钟？</p><p>这里提供了几种减少 scaling 时间的方法：</p><ul><li>调整 Horizontal Pod Autoscaler 的刷新时间（由 &ndash;horizontal-pod-autoscaler-sync-period 参数控制，默认 15s）。</li><li>调整抓取 Pod 的 CPU 和内存使用情况的间隔频率（由 metric-resolution 变量控制，默认 60s）。</li><li>调整 Cluster Autoscaler 扫描未被调度 Pod 的间隔频率（由 scan-interval 变量控制，默认10s）。</li><li>调整 Node 节点上缓存容器镜像的方式（<a href=https://github.com/senthilrch/kube-fledged target=_blank rel="external nofollow noopener noreferrer">通过诸如 kube-fledged 等工具</a>）。</li></ul><p>但即使将这些设置调整为很小的值，你仍然会收到云提供商创建计算资源的时间限制。有什么方式优化这个部分吗？</p><p>这里可以做两件事：</p><ol><li>尽可能地避免创建新地 Node 节点。</li><li>主动提前创建节点，以便在需要时能直接使用。</li></ol><h3 id=为-kubernetes-节点选择最佳实例大小>为 Kubernetes 节点选择最佳实例大小</h3><p>选择正确的节点实例类型对集群的扩展策略有很大的影响。</p><p>考虑一个这样的场景。
你有一个应用需要 1GB 的内存资源和 0.1 vCPU 资源。
你提供的 Node 节点有 4GB 的内存资源和 1 vCPU 资源。
在为操作系统、kubelet 和驱逐阀值保留内存和 CPU 后，将拥有约 2.5GB 的内存资源和 0.7 vCPU 可用于运行 Pod。
所以你的 Node 节点只能承载 2 个 Pod 的运行。</p><p><figure><a class=lightgallery href=k8s-node-instance.png title=k8s-node-instance.png data-thumbnail=k8s-node-instance.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=k8s-node-instance.png data-srcset="k8s-node-instance.png, k8s-node-instance.png 1.5x, k8s-node-instance.png 2x" data-sizes=auto alt=k8s-node-instance.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>每次扩展 Pod 副本时，都可能会产生最多 7 分钟的延迟（触发 HPA，CA 和云提供商配置计算资源的前置时间）。</p><p>让我们来看看如果改成提供 64GB 的内存和 16 vCPU 的节点会发生什么。</p><p>在为操作系统、kubelet 和驱逐阀值保留内存和 CPU 后，将拥有约 58.32GB 的内存资源和 15.8 vCPU 可用于运行 Pod。</p><p>Node 节点可以承载 58 个 Pod 的运行，只有超过 58 个 Pod 副本时，才需要一个新的节点。</p><p><figure><a class=lightgallery href=k8s-node-instance-2.png title=k8s-node-instance-2.png data-thumbnail=k8s-node-instance-2.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=k8s-node-instance-2.png data-srcset="k8s-node-instance-2.png, k8s-node-instance-2.png 1.5x, k8s-node-instance-2.png 2x" data-sizes=auto alt=k8s-node-instance-2.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>此外，每次向集群中添加节点时，都可以部署多个 Pod。再次触发 Cluster Autoscaler 的机会更少。</p><p>选择大型节点实例类型还有另一个好处。
为 kubelet 预留的资源、操作系统和驱逐阀值与运行 Pod 的可用资源之间的比率更大。
看看这张图，它描绘了 Pod 可用的内存。</p><p><figure><a class=lightgallery href=node-available-to-pod.png title=node-available-to-pod.png data-thumbnail=node-available-to-pod.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=node-available-to-pod.png data-srcset="node-available-to-pod.png, node-available-to-pod.png 1.5x, node-available-to-pod.png 2x" data-sizes=auto alt=node-available-to-pod.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>随着 Node 实例大小的增加，你可以注意到（按比例）可用于 Pod 的资源增加。换句话说，与拥有两个大小一半的实例相比，可以更高效地利用资源。</p><p>那应该一直选择最大的实例吗？</p><p>节点上可以拥有的 Pod 数量决定了效率的峰值。</p><p>一些云提供商将 Pod 的数量限制为 110 个（比如 GKE）。其他一些限制是由底层网络基于每个实例（即AWS）规定的。</p><blockquote><p><a href="https://docs.google.com/spreadsheets/d/1RPpyDOLFmcgxMCpABDzrsBYWpPYCIBuvAoUQLwOGoQw/edit#gid=907731238" target=_blank rel="external nofollow noopener noreferrer">你可以在这里查看大多数云提供商的限制</a></p></blockquote><p>所以选择更大的实例类型并不总是一个好的选择。</p><p>我们还需要考虑：</p><ol><li>爆炸半径 - 如果你只有几个节点，那么一个失败节点的影响比你有很多节点的影响更大。</li><li>自动伸缩的成本更高，因为下一个增量是（非常）大的节点。</li></ol><p>假设你为集群选择了正确的实例类型，你在配置新计算单元时可能仍然会遇到延迟。</p><p>如果不是在需要扩展时创建新节点，而是提前创建相同的节点会怎么样？</p><h3 id=在-kubernetes-集群中过度配置节点>在 Kubernetes 集群中过度配置节点</h3><p>如果你可以负担得起随时可用的备用节点的话，你可以：</p><ol><li>提前创建一个空的 Node 节点。</li><li>一旦空的 Node 节点上有 Pod 了，就会创建另一个空的 Node 节点。</li></ol><p>换句话说，让 Cluster Autoscaler 总是保持有一个备用的空 Node 节点。</p><p>这是一种权衡：你会产生额外的成本，但扩展新节点的速度会提高。</p><p>但有坏消息和好消息。</p><p>坏消息是 Cluster Autoscaler 没有内置此功能。它不能被显式的配置，并且也没有提供相应的参数。</p><p>好消息是你仍然可以通过一些 trick 的方式来达到这个目的。</p><p>你可以运行具有足够请求的 Deployment 来保留一个完整的 Node 节点。你可以将这些 Pod 视为占位符 - 它旨在保留空间，而不是使用资源。</p><p>一旦创建了真正的 Pod，就可以驱逐占位符并部署真正的 Pod。</p><p>请注意，这一次你仍然需要等待 5 分钟才能将节点添加到集群中，但你可以继续使用当前节点。同时，在后台又提供了一个新的节点。</p><p>如何做到这一点呢？</p><p>可以使用运行永久休眠的 pod 的部署来配置过度配置。</p><p><figure><a class=lightgallery href=overprovision.png title=overprovision.png data-thumbnail=overprovision.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=overprovision.png data-srcset="overprovision.png, overprovision.png 1.5x, overprovision.png 2x" data-sizes=auto alt=overprovision.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>上图中，你需要特别关注内存和 CPU 配置。Scheduler 会使用这些值来决定部署 Pod 的位置。在这种特殊情况下，它们用于保留空间。</p><p>你可以配置一个大型 Pod，该 Pod 的请求大致与可用节点资源相匹配。同时要确保你考虑了 kubelet、操作系统、kube-proxy 等消耗的资源。</p><p>如果你的节点实例是 2 vCPU 和 8GB 内存，并且 pod 的可用空间是 1.73 vCPU 和 ~5.9GB 内存，则该节点就无法承载这个 Pod，因为实际的 Pod 可用资源是要小于所需资源的。</p><p><figure><a class=lightgallery href=placeholder.png title=placeholder.png data-thumbnail=placeholder.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=placeholder.png data-srcset="placeholder.png, placeholder.png 1.5x, placeholder.png 2x" data-sizes=auto alt=placeholder.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>为了确保在创建真正的 Pod 时能快速的驱逐占位Pod，可以使用<a href=https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/ target=_blank rel="external nofollow noopener noreferrer">优先级和抢占</a>。</p><p>Pod Priority 表示一个 Pod 相对于其他 Pod 的重要性。</p><p>当一个 Pod 无法被调度时，Scheduler 会尝试抢占（驱逐）较低优先级的 Pod 以调度 “pending” 的 Pod。</p><p>可以使用 PodPriorityClass 在集群中配置 Pod 优先级：</p><p><figure><a class=lightgallery href=podpriority.png title=podpriority.png data-thumbnail=podpriority.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=podpriority.png data-srcset="podpriority.png, podpriority.png 1.5x, podpriority.png 2x" data-sizes=auto alt=podpriority.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>由于 Pod 的默认优先级为 0，而过度配置的 PriorityClass 值为 -1，因此当集群空间不足时，这些 Pod 将首先被逐出。</p><p>PriorityClass 还有两个可选字段：globalDefault 和 description。</p><ul><li>description 字段是提供给人阅读的关于 PriorityClass 的描述信息。</li><li>globalDefault 字段表示这个 PriorityClass 的值应该用于没有 priorityClassName 的 Pod。系统中只能存在一个 global Default 设置为 true 的 PriorityClass。</li></ul><p>你可以使用下面的命令为你的 Pod 指定优先级：</p><p><figure><a class=lightgallery href=priorityClassName.png title=priorityClassName.png data-thumbnail=priorityClassName.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=priorityClassName.png data-srcset="priorityClassName.png, priorityClassName.png 1.5x, priorityClassName.png 2x" data-sizes=auto alt=priorityClassName.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>设置完成！</p><p>当集群中没有足够的资源时，Pause Pod 会被抢占，并由新的 Pod 取而代之。</p><p>由于 Pause pod 变得不可调度，它会强制 Cluster Autoscaler 向集群添加更多节点。</p><p>现在，你已准备好过度配置集群，该是时候考虑优化应用程序以进行扩展了。</p><h3 id=为-pod-选择正确的内存和cpu资源>为 Pod 选择正确的内存和CPU资源</h3><p>Cluster Autoscaler 会根据 pending Pod 的出现来做出 scaling 决策。</p><p>Kubernetes Scheduler 根据 Node 节点的内存和 CPU 负载情况决定将 Pod 分配（或不分配）给节点。</p><p>因此，必须为你的工作负载设置正确的资源使用请求，否则您可能会过晚（或过早）触发自动伸缩机制。</p><p>让我们看一个例子。</p><p>您决定要测试一个应用程序，并发现：</p><ul><li>在平均负载下，应用程序消耗 512MB 内存和 0.25 vCPU。</li><li>在高峰期，应用程序应最多消耗 4GB 内存和 1 vCPU。</li></ul><p><figure><a class=lightgallery href=app-workload.png title=app-workload.png data-thumbnail=app-workload.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=app-workload.png data-srcset="app-workload.png, app-workload.png 1.5x, app-workload.png 2x" data-sizes=auto alt=app-workload.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>你的容器的限制应该是 4GB 内存和 1 个 vCPU。但是，请求呢？</p><p>Scheduler 在创建 Pod 之前使用 Pod 的内存和 CPU 请求来选择最佳节点。</p><p>所以你可以：</p><ol><li>将请求设置为低于实际平均使用量。</li><li>保守一点，分配更接近限制的请求。</li><li>设置请求以匹配实际的限制。</li></ol><p><figure><a class=lightgallery href=cpu-requests-1.png title=cpu-requests-1.png data-thumbnail=cpu-requests-1.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=cpu-requests-1.png data-srcset="cpu-requests-1.png, cpu-requests-1.png 1.5x, cpu-requests-1.png 2x" data-sizes=auto alt=cpu-requests-1.png></a><figcaption class=image-caption>:size=700</figcaption></figure><figure><a class=lightgallery href=cpu-requests-2.png title=cpu-requests-2.png data-thumbnail=cpu-requests-2.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=cpu-requests-2.png data-srcset="cpu-requests-2.png, cpu-requests-2.png 1.5x, cpu-requests-2.png 2x" data-sizes=auto alt=cpu-requests-2.png></a><figcaption class=image-caption>:size=700</figcaption></figure><figure><a class=lightgallery href=cpu-requests-3.png title=cpu-requests-3.png data-thumbnail=cpu-requests-3.png data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=cpu-requests-3.png data-srcset="cpu-requests-3.png, cpu-requests-3.png 1.5x, cpu-requests-3.png 2x" data-sizes=auto alt=cpu-requests-3.png></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>定义低于实际使用的请求是有问题的，因为你的节点经常会被过度使用。</p><p>例如，你可以分配 256MB 的内存作为内存请求。Scheduler 可以为每个节点安装两倍的 Pod。然而，Pod 在实践中使用两倍的内存并开始竞争资源 (CPU) 并被驱逐（节点上没有足够的内存）。</p><p><figure><a class=lightgallery href=https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg title=https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg data-thumbnail=https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg data-srcset="https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg, https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg 1.5x, https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg 2x" data-sizes=auto alt=https://learnk8s.io/a/22fdf4559d43e563b3b9b0472ea68969.svg></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>过度使用节点会导致过多的驱逐、更多的 kubelet 工作和大量的重新调度。</p><p>如果将请求设置为与限制相同的值会发生什么？</p><p>在 Kubernetes 中，这通常被称为 Guaranteed Quality of Service 类，指的是 pod 不太可能被终止和驱逐。Scheduler 将为分配的节点上的 Pod 保留整个 CPU 和内存。该类 Pod 运行稳定，但同时该节点的使用效率就会比较低。</p><p>如果你的应用平均使用 512MB 的内存，但为它预留了 4GB，那么大部分时间有 3.5GB 未使用。</p><p><figure><a class=lightgallery href=https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg title=https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg data-thumbnail=https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg data-sub-html="<h2>:size=700</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg data-srcset="https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg, https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg 1.5x, https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg 2x" data-sizes=auto alt=https://learnk8s.io/a/3661626fe6a72a79770b9f8e2139e015.svg></a><figcaption class=image-caption>:size=700</figcaption></figure></p><p>这值得么？</p><p>如果你想要更多的稳定性，是值得的。</p><p>如果你想要效率，你可能希望降低请求并在这些请求与限制之间找到平衡。</p><p>这通常被称为 Burstable Quality of Service 类，指的是 Pod 消耗稳定但偶尔会突然使用更多内存和 CPU。</p><p>当你的请求与应用的实际使用相匹配时，Scheduler 将高效地将你的 Pod 打包到你的节点中。</p><p>有时，应用程序可能需要更多内存或 CPU。</p><ol><li>如果 Node 中有资源，应用程序将会在达到最低消耗之前使用它们。</li><li>如果 Node 中资源不足，Pod 将竞争资源（CPU），kubelet 可能会尝试驱逐 Pod（内存）。</li></ol><p>此时，你应该使用 Guaranteed Quality of Service 还是 Burstable Quality of Service？</p><p>这取决于如下两点：</p><ol><li>当你希望最小化 Pod 的重新调度和驱逐时，请使用 Guaranteed Quality of Service（请求等于限制）。 一个很好的例子是用于数据库的 Pod。</li><li>当你想要优化集群并明智地使用资源时，请使用 Burstable Quality of Service（请求匹配实际平均使用情况）。 如果您有 Web 应用程序或 REST API，您可能希望使用 Burstable Quality of Service。</li></ol><p>那如何选择正确的请求和限制值？</p><p>你应该分析应用程序并测量空闲、负载和峰值时的内存和 CPU 消耗。更直接的策略包括部署 Vertical Pod Autoscaler 并等待它建议正确的值。</p><p>Vertical Pod Autoscaler 从 Pod 收集数据并应用回归模型来推断请求和限制。</p><p><a href=https://learnk8s.io/setting-cpu-memory-limits-requests target=_blank rel="external nofollow noopener noreferrer">您可以在本文中了解有关如何执行此操作的更多信息</a>。</p><h3 id=关于集群的缩容>关于集群的缩容</h3><p>每 10 秒，只有当请求利用率低于 50% 时，Cluster Autoscaler 才会决定删除节点。</p><p>换句话说，对于同一节点上的所有 Pod，它会汇总 CPU 和内存请求。</p><p>如果它们低于节点容量的一半，Cluster Autoscaler 将考虑当前节点进行缩减。</p><blockquote><p>值得注意的是，Cluster Autoscaler 不考虑实际的 CPU 和内存使用或限制，而只查看资源请求。</p></blockquote><p>在移除节点之前，Cluster Autoscaler 执行：</p><ul><li>Pod 检查以确保 Pod 可以移动到其他节点。</li><li>Node 节点检查以防止节点过早被破坏。</li></ul><p>如果检查通过，Cluster Autoscaler 将从集群中删除节点。</p><h3 id=为什么不基于内存或cpu进行自动伸缩>为什么不基于内存或CPU进行自动伸缩</h3><p>在扩缩容时，基于 CPU 或内存的 Cluster Autoscaler 不关心 pod。</p><p>想象一下，有一个只有一个节点的集群，并设置 Autoscaler 来添加一个新节点当 CPU 使用率达到总容量的 80%。</p><p>然后你决定创建一个具有 3 个副本的 Deployment。三个 Pod 的总资源使用率达到了 CPU 的 85%。</p><p>一个新的 Node 节点被提供。如果你不需要更多 Pod 怎么办？你有一个完整节点处于空闲的状态——这不是很好。这种使用 Autoscaler 的方式是不鼓励的。</p><h2 id=总结>总结</h2><p>在 Kubernetes 中定义和实施成功的扩缩容策略需要您掌握几个主题：</p><ul><li>熟悉 Kubernetes 节点中的可分配资源。</li><li>微调 Metrics Server、Horizontal Pod Autoscaler 和 Cluster Autoscalers 的刷新间隔。</li><li>规划集群和节点实例大小。</li><li>做好容器镜像的缓存。</li><li>做好应用程序基准测试和分析。</li></ul><p>但是上面这些还不够，你还需要使用适当的监控工具，反复测试您的扩缩容策略并调整集群的节点创建速度和成本。</p><p><a href=https://cloudnative.to/blog/kubernetes-autoscaling-strategy/ target=_blank rel="external nofollow noopener noreferrer">https://cloudnative.to/blog/kubernetes-autoscaling-strategy/</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-03-16 14:55:47">更新于 2023-03-16</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/a18401/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略 data-hashtags=自动伸缩><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://www.alongparty.cn/posts/a18401/ data-hashtag=自动伸缩><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略 data-web><i class="fa-brands fa-whatsapp fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略><i class="fa-brands fa-weibo fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略 data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略 data-description><i class="fa-brands fa-blogger fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://www.alongparty.cn/posts/a18401/ data-title=如何选择最佳的Kubernetes集群自动伸缩策略><i class="fa-brands fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E8%87%AA%E5%8A%A8%E4%BC%B8%E7%BC%A9/>自动伸缩</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/3e3c43/ class=prev rel=prev title=SLA和运维指标><i class="fa-solid fa-angle-left fa-fw"></i>SLA和运维指标</a>
<a href=/posts/5a662f/ class=next rel=next title="Istio Proxy Access日志">Istio Proxy Access日志<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kbsonlong/devops.alongparty.cn data-repo-id=R_kgDOHE7F-Q data-category=Announcements data-category-id=DIC_kwDOHE7F-c4CPP5J data-mapping=title data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/>kbsonlong</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw"></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span></div><div class="footer-line beian"><span class="icp footer-divider"><a target=_blank href=https://beian.miit.gov.cn/>粤ICP备18122209号</a></span></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><a href=https://github.com/kbsonlong title="在 GitHub 上查看源代码" target=_blank rel="external nofollow noopener noreferrer" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript src=/lib/pangu/pangu.min.js defer></script><script type=text/javascript src=/lib/cell-watermark/watermark.min.js defer></script><script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{giscus:{darkTheme:"dark",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,enablePangu:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"WFOR67TML1",algoliaIndex:"along",algoliaSearchKey:"ea1fe535f9a7ae353f3922489c829cc1",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},watermark:{appendto:".wrapper\u003emain",colspacing:30,content:'\u003cimg class="fixit-icon" src="/favicon-16x16.png" alt="FixIt logo" /\u003e FixIt 主题',enable:!0,fontfamily:"inherit",fontsize:.85,height:21,opacity:.0125,rotate:15,rowspacing:60,width:150}}</script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/js/_custom.min.js defer></script></body></html>